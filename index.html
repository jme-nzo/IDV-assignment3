<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>D3 — Replica sketch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/d3@7"></script>
  <style>
    html, body { height:100%; margin:0; }
    body { background:#fff; font-family: "Times New Roman", Georgia, serif; }
    #wrap { width:100vw; height:100vh; display:flex; align-items:center; justify-content:center; }
    text.math { font-style: italic; font-weight: 600; fill:#3a2a16; }
    .grid line { stroke:#6e6e6e; stroke-width:2; }
    .border { fill:none; stroke:#6e6e6e; stroke-width:4; }
    .vec { stroke:#373737; stroke-width:3.5; fill:none; }
    .vec-dashed { stroke:#3e5964; stroke-width:4; fill:none; stroke-dasharray:10,10; }
    .tick-mid { stroke:#3e5964; stroke-width:4; stroke-dasharray:10,10; }
    .axispt { fill:#373737; }
  </style>
</head>
<body>
<div id="wrap">
  <svg id="svg" width="1500" height="680"></svg>
</div>

<script>
/* --- sizing --- */
const svg   = d3.select("#svg");
const W     = +svg.attr("width");
const H     = +svg.attr("height");
const m     = {top:48, right:48, bottom:48, left:48};
const iw    = W - m.left - m.right;
const ih    = H - m.top - m.bottom;

/* --- grid settings (10 x 5 like the photo) --- */
const cols = 10, rows = 5;
const cw = iw / cols, rh = ih / rows;

/* container */
const g = svg.append("g").attr("transform", `translate(${m.left},${m.top})`);

/* frame / border */
g.append("rect")
  .attr("class","border")
  .attr("x", 2).attr("y", 2)
  .attr("width", iw-4).attr("height", ih-4);

/* grid lines */
const grid = g.append("g").attr("class","grid");
for (let c = 1; c < cols; c++) {
  grid.append("line")
      .attr("x1", c*cw).attr("y1", 0)
      .attr("x2", c*cw).attr("y2", ih);
}
for (let r = 1; r < rows; r++) {
  grid.append("line")
      .attr("x1", 0).attr("y1", r*rh)
      .attr("x2", iw).attr("y2", r*rh);
}

/* simple helpers to go from grid coords to pixels (0..cols, 0..rows from left/bottom) */
const X = c => c * cw;
const Y = r => ih - r * rh;

/* --- key points approximated from your image --- */
const p_beta2  = {x: 2.8, y: 1.0};  // e^β_2 near bottom-left
const p_beta1  = {x: 6.2, y: 1.0};  // e^β_1 near bottom-mid-right
const p_alpha2 = {x: 4.9, y: 3.9};  // e^α_2 upper middle
const p_alpha1 = {x: 8.0, y: 3.9};  // e^α_1 upper right

/* markers for arrowheads */
svg.append("defs")
  .append("marker")
    .attr("id","arrow")
    .attr("orient","auto")
    .attr("markerWidth",12)
    .attr("markerHeight",12)
    .attr("refX",10).attr("refY",6)
  .append("path")
    .attr("d","M 0 0 L 12 6 L 0 12 z")
    .attr("fill","#3e5964");

/* --- solid vectors --- */
g.append("line")
  .attr("class","vec")
  .attr("x1", X(p_beta2.x)).attr("y1", Y(p_beta2.y))
  .attr("x2", X(p_alpha2.x)).attr("y2", Y(p_alpha2.y));

g.append("line")
  .attr("class","vec")
  .attr("x1", X(p_beta1.x)).attr("y1", Y(p_beta1.y))
  .attr("x2", X(p_alpha1.x)).attr("y2", Y(p_alpha1.y));

/* --- dashed vectors (with arrowheads pointing back toward β points, like your photo) --- */
g.append("line")
  .attr("class","vec-dashed")
  .attr("x1", X(p_alpha1.x)).attr("y1", Y(p_alpha1.y))
  .attr("x2", X(p_beta2.x)).attr("y2", Y(p_beta2.y))
  .attr("marker-end","url(#arrow)");

g.append("line")
  .attr("class","vec-dashed")
  .attr("x1", X(p_alpha2.x)).attr("y1", Y(p_alpha2.y))
  .attr("x2", X(p_beta1.x)).attr("y2", Y(p_beta1.y))
  .attr("marker-end","url(#arrow)");

/* small dashed tick at the crossing of dashed lines */
function lineIntersection(a1,a2,b1,b2){
  const x1 = X(a1.x), y1 = Y(a1.y),
        x2 = X(a2.x), y2 = Y(a2.y),
        x3 = X(b1.x), y3 = Y(b1.y),
        x4 = X(b2.x), y4 = Y(b2.y);

  const den = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
  const px = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4)) / den;
  const py = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4)) / den;
  return {x:px, y:py};
}
const mid = lineIntersection(p_alpha1, p_beta2, p_alpha2, p_beta1);
g.append("line")
  .attr("class","tick-mid")
  .attr("x1", mid.x - 22).attr("y1", mid.y)
  .attr("x2", mid.x + 22).attr("y2", mid.y);

/* --- tiny arrow cues at β points (left/down facing as in photo) --- */
const tiny = 16;
g.append("path")
  .attr("class","vec")
  .attr("d", `M ${X(p_beta2.x)} ${Y(p_beta2.y)} l -${tiny} -${tiny/3}`)
  .attr("marker-end","url(#arrow)");
g.append("path")
  .attr("class","vec")
  .attr("d", `M ${X(p_beta1.x)} ${Y(p_beta1.y)} l 0 ${tiny}`)
  .attr("marker-end","url(#arrow)");

/* --- labels e^α_1, e^α_2, e^β_1, e^β_2 --- */
function addMathLabel(p, superscript, subscript, dx, dy){
  const t = g.append("text")
    .attr("class","math")
    .attr("x", X(p.x) + (dx||0))
    .attr("y", Y(p.y) + (dy||0));
  t.append("tspan").text("e");
  t.append("tspan").text(superscript).attr("dy","-0.55em").attr("font-size","75%");
  t.append("tspan").text(subscript).attr("dy","0.85em").attr("dx","-0.35em");
}
addMathLabel(p_alpha1, "α", "1", -18, -18);
addMathLabel(p_alpha2, "α", "2", -18, -18);
addMathLabel(p_beta1 , "β", "1",  -12,  42);
addMathLabel(p_beta2 , "β", "2",  -22,  42);
</script>
</body>
</html>
